{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "08ceb8b1_3433c8b1",
        "filename": "rust/bssl-crypto/src/aes.rs",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 14196
      },
      "writtenOn": "2024-01-12T20:03:30Z",
      "side": 1,
      "message": "Well, it also differs in that the usual boringssl convention is 1 for success and 0 or failure, and this is 0 for success or a negative number for failure. which took me down a bit of a signed/unsigned rabbit hole on the bitwise xor conversion and if we could end up with a negative corner case here.\n\nHonestly rather than think about it, once I gave initialized_struct_fallible a success_value parameter and changed the calls in this stack I was happier. \n\nI.E. this - with the call sites changed to have a success value of 0 or 1\nappropriately. \n\ndiff --git a/rust/bssl-crypto/src/lib.rs b/rust/bssl-crypto/src/lib.rs\nindex c71a989e3..7c2125560 100644\n--- a/rust/bssl-crypto/src/lib.rs\n+++ b/rust/bssl-crypto/src/lib.rs\n@@ -260,16 +260,16 @@ where\n \n /// Returns a BoringSSL structure that is initialized by some function.\n /// Requires that the given function completely initializes the value or else\n-/// returns a value other than one.\n+/// returns a value other than the success_value argument.\n ///\n /// (Tagged `unsafe` because a no-op argument would otherwise expose\n /// uninitialized memory.)\n-unsafe fn initialized_struct_fallible\u003cT, F\u003e(init: F) -\u003e Option\u003cT\u003e\n+unsafe fn initialized_struct_fallible\u003cT, F\u003e(init: F, success_value: i32) -\u003e Option\u003cT\u003e\n where\n     F: FnOnce(*mut T) -\u003e core::ffi::c_int,\n {\n     let mut out_uninit \u003d core::mem::MaybeUninit::\u003cT\u003e::uninit();\n-    if init(out_uninit.as_mut_ptr()) \u003d\u003d 1 {\n+    if init(out_uninit.as_mut_ptr()) \u003d\u003d success_value {\n         Some(unsafe { out_uninit.assume_init() })\n     } else {\n         None",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 122,
        "endChar": 49
      },
      "revId": "185e58f2aeac8b30d09f6d85bb25472e098950fd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39da4a3a_629ba41a",
        "filename": "rust/bssl-crypto/src/aes.rs",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 5415
      },
      "writtenOn": "2024-01-12T20:34:49Z",
      "side": 1,
      "message": "We could also just make `F` return a `bool` and make the caller stick a `!\u003d 0` or `\u003d\u003d 0` in there as appropriate.",
      "parentUuid": "08ceb8b1_3433c8b1",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 122,
        "endChar": 49
      },
      "revId": "185e58f2aeac8b30d09f6d85bb25472e098950fd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7428a5f_ecf1ff0f",
        "filename": "rust/bssl-crypto/src/aes.rs",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 5415
      },
      "writtenOn": "2024-01-12T20:35:38Z",
      "side": 1,
      "message": "(An `Option` or `Result` type would probably be less ambiguous, but going from an `i32` to those is quite a lot more typing.)",
      "parentUuid": "39da4a3a_629ba41a",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 122,
        "endChar": 49
      },
      "revId": "185e58f2aeac8b30d09f6d85bb25472e098950fd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b9d06a9_39b642b0",
        "filename": "rust/bssl-crypto/src/aes.rs",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 14196
      },
      "writtenOn": "2024-01-12T21:40:58Z",
      "side": 1,
      "message": "yes, I pondered just making F return a bool as well, but this is sort of the minimum, and IMO makes it clear that you have to actually think about what the boringssl function is returning, but (shrug). I\u0027m very happy with either way though :)",
      "parentUuid": "c7428a5f_ecf1ff0f",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 122,
        "endChar": 49
      },
      "revId": "185e58f2aeac8b30d09f6d85bb25472e098950fd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b0d2127_0558607c",
        "filename": "rust/bssl-crypto/src/aes.rs",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 5005
      },
      "writtenOn": "2024-01-18T21:36:39Z",
      "side": 1,
      "message": "Ok :) Made it return a `bool`. I\u0027ll update all the other other uses to `\u003d\u003d 1` and be explicit about the expected return value.",
      "parentUuid": "9b9d06a9_39b642b0",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 122,
        "endChar": 49
      },
      "revId": "185e58f2aeac8b30d09f6d85bb25472e098950fd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}