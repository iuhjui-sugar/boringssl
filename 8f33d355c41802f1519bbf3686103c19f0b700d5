{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "13829447_802cf80c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "Oops. Took longer to wordsmith the comment than I expected, but I\u0027ll go ahead and flush the comments now. The one about the callback will probably change a decent amount of the state you need to track anyway.",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a878b9f_4416728c",
        "filename": "crypto/hpke/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "Oh hah. Right, we would want to export that wouldn\u0027t we? :-)",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67d40408_3b06c18d",
        "filename": "include/openssl/ssl.h",
        "patchSetId": 4
      },
      "lineNbr": 3579,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "Some comments.\n\n1. I see the spec says \"retry keys\", but I think this is a mistake. It\u0027s a remnant of when the field was retry_keys and the type was ESNIKeys. I\u0027ll go fix this.\n\n2. Using the last config is weird. We usually say the first entry in a list the most preferred one. We also need to be able to send multiple values in retry_configs. (Different key types and different ECH versions.) Perhaps we want to just do all of them? Not sure. Note that, if we do use all of them, we still need to tell the caller that the order matters. (See https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-5-8.2.1 )\n\n3. Let\u0027s add a bit more guidance on how to use this API, both in how to use it and how it works with our callbacks. (Usually I try to aim for a caller who is vaguely aware of how ECH works, is not familiar with the detailed spec, and certainly does not know how it maps to BoringSSL\u0027s API.) Perhaps:\n\n\nSSL_add_ech_private_key adds an ECHConfig in |ech_config| and its corresponding private key in |private_key| to |ssl|. It returns one on success and zero on error. |ssl|, as a server, uses these keys to decrypt incoming encrypted CHs.\n\nThis function should be called in decreasing order of preference and must be configured before the handshake starts.\n\nThe configured ECHConfigs should also be advertised out-of-band via DNS (see draft-ietf-dnsop-svcb-https). Before advertising an ECHConfig in DNS, deployments should ensure all instances of the service are configured with the ECHConfig and corresponding private key.\n\nIf there is a mismatch, |ssl| will complete the handshake using the cleartext ClientHello and send updated ECHConfigs to the client. The client will then retry to recover, but with a latency penalty. This recovery flow depends on the public name in the ECHConfig. Before advertising an ECHConfig in DNS, deployments must ensure all instances of the service can present a valid certificate for the public name.\n\nBoringSSL negotiates ECH before certificate selection callbacks are called, including |SSL_CTX_set_select_certificate_cb|. If ECH is negotiated, the reported |SSL_CLIENT_HELLO| structure and |SSL_get_servername| function will transparently reflect the inner ClientHello. Callers should select parameters based on these values to correctly handle ECH as well as the recovery flow.",
      "range": {
        "startLine": 3578,
        "startChar": 73,
        "endLine": 3579,
        "endChar": 15
      },
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "082de32b_b415b3c3",
        "filename": "include/openssl/ssl.h",
        "patchSetId": 4
      },
      "lineNbr": 3579,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "1. Good catch, I believe this was actually an independent mistake.\n\n2. Agreed that using the last config is weird. That comment was also inaccurate -- I\u0027m actually serializing all ECHConfigs in the order they were registered in |ext_ech_add_serverhello|.\n\n3. Using this text with a few edits. Thanks!",
      "parentUuid": "67d40408_3b06c18d",
      "range": {
        "startLine": 3578,
        "startChar": 73,
        "endLine": 3579,
        "endChar": 15
      },
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "696aa5e8_287e0372",
        "filename": "ssl/handshake_server.cc",
        "patchSetId": 4
      },
      "lineNbr": 589,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "We shouldn\u0027t parse the ClientHello extensions this early. The processing order is to give the caller a chance to reconfigure things in select_certificate_cb before bulk processing has happened.\n\nAlso those callbacks, in general, get to assume the version has been negotiated already. A core invariant like that really shouldn\u0027t differ between based on a boolean. The parse functions also, in general, mutate things (they have stash values and make negotiation decisions) so it\u0027s very risky to call them multiple times, particularly on different ClientHellos. This is in contrast to the serialization callbacks, which generally just write out negotiated state.\n\n(You see this in how the CL end up having to no-op most of the callbacks.) \n\nRather, the flow should be:\n\n- Use ssl_client_hello_get_extension to see if there is an encrypted_client_hello extension. If so, resolve it. Now we either have left the ClientHello alone (using the outer CH), or we\u0027ve replaced it with an inner CH.\n\n- In all subsequent processing, use the resulting CH. In particular, we never call ssl_parse_clienthello_tlsext on the outer ClientHello if we\u0027re actually using the inner one. You mostly ignore the ClientHello that you don\u0027t use.\n\nThat also tidies up the ech_is_inner behavior. You should think about this in terms of a ClientHello dispatcher sitting in front of the main server. ech_is_inner is part of backend server behavior, so it can just run after we\u0027ve decided which ClientHello to use. (It\u0027s possible this\u0027ll need to change the ech_present business, which is fine. I wouldn\u0027t expect the core ECH extension to use callbacks much. Callbacks are generally for independent extensions anyway.)",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12267d5e_fecdf405",
        "filename": "ssl/handshake_server.cc",
        "patchSetId": 4
      },
      "lineNbr": 589,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "Makes sense! Done.",
      "parentUuid": "696aa5e8_287e0372",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b86b71ef_cf90efc9",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1698,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "Nit: 80 chars",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d7bb731_43ad7069",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1698,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b86b71ef_cf90efc9",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ec1677e_d108778c",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1700,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "This and the above are already stored in the HPKE context. Let\u0027s just add some getters and check against that.",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "caf4b8f3_d5b26a11",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1700,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9ec1677e_d108778c",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc8c4322_acd6e37a",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1749,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "What\u0027s the difference between this and ech_is_inner_present? (Something called ech_accept should specifically be about accepting ECH, not merely seeing ech_is_inner.)",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0e68b17_9a33624c",
        "filename": "ssl/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 1749,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "Currently, ech_accept is set to true when the server successfully decrypts the ClientHelloInner and effectively replaces the ClientHelloOuter, or when it\u0027s decided that it\u0027s a backend server (has ech_is_inner and no encrypted_client_hello extension).\n\nNo problem to refactor and only set to true when the server successfully decrypts the ClientHelloInner.",
      "parentUuid": "dc8c4322_acd6e37a",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "778bc01e_a53d7cfe",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "From VC, rather than doubling all this up, just use the deriveSecretPeek function you already added.",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aba35514_388cda3d",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "I\u0027m running into an issue with HRR because calling hs.finishedHash.UpdateForHelloRetryRequest [1] locks in my choice of CHI vs CHO. It actually resets the internal hash.Hash objects, so I can\u0027t really simulate it with deriveSecretPeek.\n\nAlso, I can\u0027t make a throwaway copy of hs.finishedHash at line 1088 because hash.Hash is uncopyable.\n\nOne alternative would be to add a Reset function to finishedHash. We could barrel ahead down the [CHI, HRR, CHI2, SH] path and then reset/rehash [CHO, HRR, CHO2, SH] only if accept_confirmation !\u003d SH.Random[-8:]. But I don\u0027t think this is much more desirable than the current double-transcript approach.\n\nDo you have any better ideas?\n\n[1]: https://source.chromium.org/chromium/chromium/src/+/master:third_party/boringssl/src/ssl/test/runner/prf.go;l\u003d245;drc\u003dc295935a9bf345acb597ffefb69f7e095c3eee72",
      "parentUuid": "778bc01e_a53d7cfe",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84bb41f9_2d7c679a",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:43:14Z",
      "side": 1,
      "message": "Actually, I guess you can make a copy of sha256 per the BinaryMarshaler example here https://golang.org/pkg/hash/. Can we definitely state that the runner will only use SHA256 for the ECH HPKE KDF?",
      "parentUuid": "aba35514_388cda3d",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3bb515a_84c15df8",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-05T23:35:33Z",
      "side": 1,
      "message": "Oh! Handy. That\u0027s a really weird way to make a copy, but okay.\n\n\u003e Can we definitely state that the runner will only use SHA256 for the ECH HPKE KDF?\n\nYes, but I\u0027m not sure what the connection is. SHA512 (SHA384 is a truncated SHA512 with different IV) implements it too. The mention of SHA256 is just an example. The doc says all the standard library ones do.",
      "parentUuid": "84bb41f9_2d7c679a",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2a7b6bb_78f81d01",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-10T21:19:37Z",
      "side": 1,
      "message": "I had an insight on this -- there\u0027s actually no need to copy the hash.Hash fields of hs.finishedHash, because at the point where echFinishedHash and hs.finishedHash diverge, we have hashed zero messages.\n\nAt least for TLS 1.3, h.hash.New() would be equivalent to a full copy of h.client and h.server. The main thing is that we need a copy of h.secret, h.buffer, and the other primitive fields.\n\nIf I add a PartialCopyForECH() method to finishedHash, we can eliminate the echFinishedHash parameter to doTLS13Handshake as well as the duplicate calls to addEntropy and nextSecret.\n\nDoes that sound worth the effort?",
      "parentUuid": "d3bb515a_84c15df8",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f33c5d13_ac0ea92b",
        "filename": "ssl/test/runner/handshake_client.go",
        "patchSetId": 4
      },
      "lineNbr": 1046,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-03-19T16:44:27Z",
      "side": 1,
      "message": "I\u0027ll close this as it\u0027s purely about a performance optimization for tests, and we already have something that works.",
      "parentUuid": "a2a7b6bb_78f81d01",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bc27911_f5ec3321",
        "filename": "ssl/test/runner/hpke/hpke.go",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-02T23:49:25Z",
      "side": 1,
      "message": "Similar comment from the other CL: this should be in TLS, not in the core crypto bit, and, more importantly, we need runner on the client to control which cipher suite to use, so that we test the shim honors all cipher suites it is configured with.\n\nAll this means is adding an ECHCipherSuites parameter to the Config struct. And then, in tests, you can either leave it alone (the test doesn\u0027t care), or specify a particular one (the test wants to test a particular one).",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64a3d28e_d658e21b",
        "filename": "ssl/test/runner/hpke/hpke.go",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-03T18:30:48Z",
      "side": 1,
      "message": "Done.\n\nI added a test that the ECH server still accepts ClientHelloInner when the client used the server\u0027s less-preferred ciphersuite. Not terribly surprising, but I suppose it\u0027s worth checking.\n\nShould I also test the server when the client indicates an HPKE ciphersuite that isn\u0027t supported by the candidate ECHConfigs? I suppose I would need to add \"ForceECHCipherSuite\" to ProtocolBugs, or give the server an ECHConfig with different ciphersuites than the one given to the client.",
      "parentUuid": "7bc27911_f5ec3321",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6333da91_e363b630",
        "filename": "ssl/test/runner/hpke/hpke.go",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-03-22T19:25:49Z",
      "side": 1,
      "message": "Done, added test named \"ECH-Server-ClientECHUnsupportedCipherSuite\".",
      "parentUuid": "64a3d28e_d658e21b",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad2ff77_7bee9389",
        "filename": "ssl/test/test_config.cc",
        "patchSetId": 4
      },
      "lineNbr": 1601,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-01-28T20:03:32Z",
      "side": 1,
      "message": "We really should test the server with \u003e1 ECHConfigs. Should I just ship over a base64-encoded sequence of (ECHConfig,PrivateKey) pairs and parse them out here?",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c6955440_7cef4293",
        "filename": "ssl/test/test_config.cc",
        "patchSetId": 4
      },
      "lineNbr": 1601,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-02-04T16:43:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5ad2ff77_7bee9389",
      "revId": "8f33d355c41802f1519bbf3686103c19f0b700d5",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}